* Some Basic Setting
** Setting
#+BEGIN_SRC emacs-lisp

(add-to-list 'default-frame-alist '(font . "Source Code Pro"))
(set-default-font "Source Code Pro")
;; sets the default user's information properly.
(setq user-full-name    "Vishnu Dev TJ"
      user-mail-address "vishnudevtj@gmail.com")

(setq inhibit-startup-screen t                ;; the welcome screen is for guests only, I'm at home now!
      initial-scratch-message nil             ;; remove the message in the scratch buffer
      visible-bell t                          ;; remove the annoying beep
      apropos-do-all t)
;; no bars, no gui menus
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

;; replace yes/no questions with y/n
(fset 'yes-or-no-p 'y-or-n-p)

;;Setting to use vertical split
(setq split-height-threshold nil)
(setq split-width-threshold 0)

(setq explicit-shell-file-name "/bin/zsh")
(setq shell-file-name "/bin/zsh")

;;Remove Strange line 
(set-face-attribute 'vertical-border nil :foreground (face-attribute 'fringe :background))

;; make sure that UTF-8 is used everywhere.
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-language-environment    'utf-8)
(set-selection-coding-system 'utf-8)
(setq locale-coding-system   'utf-8)
(prefer-coding-system        'utf-8)
(set-input-method nil)

;;No more backup
(setq auto-save-default nil
      auto-save-list-file-prefix nil
      make-backup-files nil)

;;Hilight lines
(global-hl-line-mode 1) 

;;Scrollig
(setq scroll-margin 3
      scroll-conservatively 101
      scroll-up-aggressively 0.01
      scroll-down-aggressively 0.01
      scroll-preserve-screen-position t
      auto-window-vscroll nil
      hscroll-margin 5
      hscroll-step 5)

;;Show parens
(show-paren-mode 1)
(setq show-paren-delay 0)

(global-prettify-symbols-mode +1)
(global-set-key (kbd "C-x k") 'kill-this-buffer)

(add-to-list 'load-path "~/.emacs.d/lisp")

(set-face-attribute 'comint-highlight-prompt nil
                    :inherit nil)

(setq x-stretch-cursor t)

;; It's much easier to move around lines based on how they are displayed, rather than the actual line. This helps a ton with long log file 
;; lines that may be wrapped:
(setq line-move-visual t)

;;Hide the mouse while typing: 
(setq make-pointer-invisible t)

;; Visual line mode is set globally 
(setq global-visual-line-mode t)

;; No more tabs
(setq-default indent-tabs-mode nil)

;; Symbolic link to Git-controlled source file
(setq vc-follow-symlinks t)
#+END_SRC
** History
Maintain a history of past actions and a reasonable number of lists.
#+BEGIN_SRC emacs-lisp
(setq-default history-length 1000)
(setq history-delete-duplicates t
      savehist-save-minibuffer-history 1
      savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
(savehist-mode t)
#+END_SRC
* UI
** Theme
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  :config
  (load-theme 'doom-vibrant
	      t )
  )
;; (use-package color-theme-solarized
;;   :ensure t
;;   :config
;;   (set-terminal-parameter nil 'background-mode 'dark)
;;   (set-frame-parameter nil 'background-mode 'dark)
;;   (load-theme 'solarized t)
;;   (custom-set-faces
;;    '(ivy-minibuffer-match-face-2 ((t (:inherit highlight :weight bold))))
;;    '(ivy-minibuffer-match-face-3 ((t (:inherit highlight :weight bold))))
;;    '(ivy-minibuffer-match-face-4 ((t (:inherit highlight :weight bold)))))
;;   )
#+END_SRC 

#+RESULTS:
: t

** Space line
[[https://github.com/TheBB/spaceline][spaceline]] a modeline theme from spacemacs
#+BEGIN_SRC emacs-lisp
;; (use-package spaceline :ensure t
;;   :config
;;   (use-package spaceline-config
;;     :config
;;     (spaceline-toggle-minor-modes-off)
;;     (spaceline-toggle-buffer-encoding-off)
;;     (spaceline-toggle-buffer-encoding-abbrev-off)
;;     (setq powerline-default-separator 'rounded)
;;     (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
;;     (spaceline-define-segment line-column
;;       "The current line and column numbers."
;;       "l:%l c:%2c")
;;     (spaceline-define-segment time
;;       "The current time."
;;       (format-time-string "%H:%M"))
;;     (spaceline-define-segment date
;;       "The current date."
;;       (format-time-string "%h %d"))
;;     (spaceline-toggle-time-on)
;;     (spaceline-emacs-theme 'date 'time)))
#+END_SRC
** Doom mode line
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :defer t
  :hook (after-init . doom-modeline-init)
  :config
  (setq doom-modeline-height '20)
  )
#+END_SRC
** Ace windows for easy window switching
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :init
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :bind (("C-x o" . ace-window))
    )
#+END_SRC
** Icon
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t
    :config
    (use-package all-the-icons-ivy
      :ensure t
      :config 
      (all-the-icons-ivy-setup)
      )
    )

#+END_SRC
** Deamon
#+BEGIN_SRC emacs-lisp
    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                    (with-selected-frame frame
                      (set-terminal-parameter nil 'background-mode 'dark)
                      (set-frame-parameter nil 'background-mode 'dark)
                      (load-theme 'doom-vibrant t)
                      (set-default-font "Source Code Pro")
                      )))
      (load-theme 'doom-vibrant t))
#+END_SRC

* Org Mode
** Setting 
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window
        org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-startup-indented t
        org-imenu-depth 6)
  ;;Find all org files in a directory and addes them org-agenda-file works only in Linux
(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c C-l") 'org-insert-link)
(setq org-hide-leading-stars t)
(setq org-hide-leading-stars-before-indent-mode t)

(add-hook 'org-agenda-mode-hook (lambda () 
				  (setq org-agenda-files
					(mapcar 'abbreviate-file-name
						(split-string
						 (shell-command-to-string " find ~/Dropbox/OrgFiles -name \"*.org\" -! -name \".*.org\" ")
						 "\n")))
				  ))
(global-set-key (kbd "C-c g") 'org-agenda)

;;Expantions
;; add <el for emacs-lisp expansion
(add-to-list 'org-structure-template-alist
	     '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"
	       "<src lang=\"emacs-lisp\">\n?\n</src>"))
;; add <p for python expansion
(add-to-list 'org-structure-template-alist
	     '("p" "#+BEGIN_SRC python :results output org drawer\n?\n#+END_SRC"
	       "<src lang=\"python\">\n?\n</src>"))
;; add <sh for shell
(add-to-list 'org-structure-template-alist
	     '("sh" "#+BEGIN_SRC sh\n?\n#+END_SRC"
	       "<src lang=\"shell\">\n?\n</src>"))
;; add <ip for shell
(add-to-list 'org-structure-template-alist
	     '("ip" "#+BEGIN_SRC ipython  :session \n?\n#+END_SRC"
	       "<src lang=\"python\">\n?\n</src>"))
;; add <n for emacs-lisp expansion
(add-to-list 'org-structure-template-alist
	     '("n" "#+BEGIN_SRC nasm \n?\n#+END_SRC"
	       "<src lang=\"nasm\">\n?\n</src>"))

;; no extra indentation in the source blocks
(setq org-src-preserve-indentation t)

;;Source Block Key binding
(define-key org-mode-map (kbd "C-j") #'org-babel-next-src-block)
(define-key org-mode-map (kbd "C-k") #'org-babel-previous-src-block)
(define-key org-mode-map (kbd "s-t")
  (lambda  () (interactive) (org-babel-tangle 4 ) ))

#+END_SRC

** Packages
*** Org Bullet 

#+BEGIN_SRC emacs-lisp
  ;; (use-package org-bullets
  ;;   :ensure t
  ;;   :config
  ;;   (add-hook 'org-mode-hook 'org-bullet-mode)
  ;;   )
#+END_SRC

*** Htmlizer
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t
    )
#+END_SRC
*** Async

Asyncronous execution of org code block
#+BEGIN_SRC emacs-lisp
  ;;(use-package ob-async
  ;;  :ensure t
  ;;  )

#+END_SRC

*** Exporter
#+BEGIN_SRC emacs-lisp
  (use-package ox-gfm
    :ensure t
    )
#+END_SRC
*** Org Download
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :ensure t
  :config
  (org-download-enable)
  ;;Require Gnome Screenshot
  (setq org-download-screenshot-method " sleep 5s && gnome-screenshot -a -f %s")
  )
#+END_SRC
** Capture
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c c") 'org-capture)
(setq org-capture-templates '
      (

       ("j" "Journal Entry"
	entry (file+datetree "~/Dropbox/OrgFiles/journal.org.gpg")
	"* Event: %?\n\n  %i\n\n "A :prepend t 
	:empty-lines 1)
       ("b" "bi0s Entry"
	entry (file+datetree "~/Dropbox/bi0s/bi0s.org")
	"* Report : %?\n\n  %i\n\n" :prepend t )
       ("t" "Todo" entry (file+headline "~/Dropbox/OrgFiles/gtd/gtd.org" "Tasks")
	"* TODO  %? \nEntered on %t" :prepend t )
       ("T" "Tickler" entry (file+headline "~/Dropbox/OrgFiles/gtd/tickler.org" "Tasks")
	"* %i%? \n %U ")
       ("n" "Notes" entry (file+datetree "~/Dropbox/OrgFiles/note.org")
	"* %?  \n Entered on %t")
       ))
#+END_SRC

** Refile
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '(("~/Dropbox/OrgFiles/gtd/gtd.org" :maxlevel . 3)
                           ("~/Dropbox/OrgFiles/gtd/someday.org" :level . 1)
                           ("~/Dropbox/OrgFiles/gtd/tickler.org" :maxlevel . 2)))
#+END_SRC
** Babel
#+BEGIN_SRC emacs-lisp
;; (use-package ob-ipython
;;   :ensure t
;;   )
(use-package org
:config
(org-babel-do-load-languages 'org-babel-load-languages
'((shell         . t)
 (emacs-lisp . t)
 (perl       . t)
(python     . t)
)))
#+END_SRC

** Org Crypt
#+BEGIN_SRC emacs-lisp
(require 'epa-file)
(epa-file-enable)
(require 'org-crypt)

(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))

(setq org-crypt-key user-mail-address )
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.

(setq auto-save-default nil)

#+END_SRC

* Packages
** Hydra 

Hydra is a package for GNU Emacs that can be used to tie related commands into a family of short bindings with a common prefix - a Hydra.
#+BEGIN_SRC emacs-lisp
(use-package hydra 
  :ensure t
  :config
  (defhydra hydra-zoom (global-map "<f2>")
    "zoom"
    ("+" text-scale-increase "in")
    ("-" text-scale-decrease "out"))

  (defhydra my/hydra-file (:color blue :hint nil )
    "
                                                                                  ╭────────┐
                                                                                  │  Files │
        ──────────────────────────────────────────────────────────────────────────┴────────╯
        [_c_]onfig [_n_]ote  [_g_]td [_j_]ournal [_f_]eed  [_d_]otfile   [_b_]i0s   d[_o_]c
        -------------------------------------------------------------------------------------                           
        "
    ("c" (find-file "~/.emacs.d/config.org") )
    ("f" (find-file "~/Dropbox/OrgFiles/Emacs/elfeed.org") )
    ("g" (find-file "~/Dropbox/OrgFiles/gtd/gtd.org") )
    ("n" (find-file "~/Dropbox/OrgFiles/note.org") )
    ("d" (find-file "~/dotfiles/dotfile.org") )
    ("o" (find-file "~/Dropbox/Documents/Documents/doc.org.gpg") )
    ("j" (find-file "~/Dropbox/OrgFiles/journal.org.gpg"))
    ("b" (find-file "~/Dropbox/bi0s/bi0s.org")))

  (defhydra my/window-movement ()
    "windows"
    ("y" other-window "other")
    ("h" switch-window "switch-window")
    ("f" find-file "file")
    ("F" find-file-other-window "other file")
    ("v" (progn (split-window-right) (windmove-right)))
    ("x" (split-window-below))
    ("o" delete-other-windows :color blue)
    ("a" ace-window)
    ("s" ace-swap-window)
    ("d" delete-window "delete")
    ("D" ace-delete-window "ace delete")
    ("i" ace-maximize-window "maximize")
    ("b" helm-buffers-list)
    ("t" eshelli "shell")
    ("q" nil))
  ;;Dired Hydra
  ;; (bind-keys :map elfeed-search-mode-map
  ;; 	     ("\\"   . my/hydra-elfeed/body))

  (defhydra my/hydra-elfeed ()
    "filter"
    ("e" (elfeed-search-set-filter "@6-months-ago +emacs") "emacs")
    ("s" (elfeed-search-set-filter "@6-months-ago +security") "security")
    ("c" (elfeed-search-set-filter "@6-months-ago +comic") "comic")
    ("M" elfeed-toggle-star "Mark")
    ("A" (elfeed-search-set-filter "@6-months-ago") "All")
    ("T" (elfeed-search-set-filter "@1-day-ago") "Today")
    ("Q" bjm/elfeed-save-db-and-bury "Quit Elfeed" :color blue)
    ("q" nil "quit" :color blue)
    )

  ;;Dired Hydra
  ;; (bind-keys :map dired-mode-map
  ;; 	     ("\\"   . my/hydra-dired/body))
  (defhydra my/hydra-dired (:color pink :hint nil )
    "
                                                                                  ╭────────┐
               Nav            Mark            Action                   Other      │  Dired │
       ╭──────────────────────────────────────────────────────────────────────────┴────────╯
        ^ ^ _K_ ^ ^
        ^ ^ _k_ ^ ^      [_m_]ark           [_C_]opy      [_M_]ove      [_S_]ort
        _h_ ^✜^ _l_      [_u_]n mark        [_R_]ename    [_+_]Create   [_n_]arrow
        ^ ^ _j_ ^ ^      [_U_]nmark all     [_D_]elete    [_P_]aste     [_Z_] Compress
        ^ ^ _J_ ^ ^
        -------------------------------------------------------------------------------------                           
        "
    ;; arrows
    ("j" evil-next-line)
    ("k" evil-previous-line)
    ("l" dired-subtree-insert)
    ("h" dired-subtree-remove)

    ("J" dired-find-file)
    ("K" dired-up-directory)

    ("m" dired-mark)
    ("u" dired-unmark)
    ("U" dired-unmark-all-marks) 

    ("C" dired-ranger-copy)	
    ("R" dired-do-rename) 
    ("D" dired-do-delete	)
    ("+" dired-create-directory)	
    ("Z" dired-do-compress	)
    ("P" dired-ranger-paste)
    ("M" dired-ranger-move)

    ("S" hydra-dired-quick-sort/body)
    ("n" dired-narrow)
    ("q" nil :color blue)
    )


  (defhydra my/hydra-image (:color pink)
    "I :"
    ("+" imagex-sticky-zoom-in "zoom i")
    ("-" imagex-sticky-zoom-out "zoom o")
    ("M" imagex-sticky-maximize "maximize")
    ("O" imagex-sticky-restore-original "original")
    ("S" imagex-sticky-save-image "save")
    ("r" imagex-sticky-rotate-right "rotate r")
    ("l" imagex-sticky-rotate-left "rotate l")
    ("n" image-next-file "next")
    ("p" image-previous-file "previous")
    ("q" nill :color blue)
    )
  )


(defhydra my/hydra-applications (:color blue :hint nil )
  "
                                                                                  ╭────────┐
                                                                                  │  Files │
        ──────────────────────────────────────────────────────────────────────────┴────────╯
         [_m_]usic [_s_]ent Mail [_n_]otmuch
        -------------------------------------------------------------------------------------                           
        "
  ("m" (mingus))
  ("s" (compose-mail))
  ("n" (notmuch))
  ("q" nill :color blue)
  )
#+END_SRC

** Key Chord

#+BEGIN_SRC emacs-lisp 
  (use-package key-chord
    :ensure t
    :init
    (key-chord-mode +1)
    (setq key-chord-one-key-delay 0.16)
    (key-chord-define-global "jw"     'my/window-movement/body)
    (key-chord-define-global "jf"     'my/hydra-file/body)
    (key-chord-define-global "jd"     'my/hydra-dired/body)
    (key-chord-define-global "je"     'my/hydra-elfeed/body)
    (key-chord-define-global "ji"     'my/hydra-image/body)
    (key-chord-define-global "ja"     'my/hydra-applications/body)
    )
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (use-package counsel-projectile
    :ensure t
    :config
    (counsel-projectile-mode)
    )
  (projectile-mode)
  )
#+END_SRC

** Avy
[[https://github.com/abo-abo/avy][avy]]i is a GNU Emacs package for jumping to visible text using a char-based decision tree.
See also ace-jump-mode and vim-easymotion - avy uses the same idea.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
    (setq avy-all-windows t)
    (setq avy-background t)
    :bind (("C-c a" . avy-goto-char-2))
    )
#+END_SRC
** Smex
[[https://github.com/nonsequitur/smex/][Smex]] is a M-x enhancement for Emacs. Built on top of Ido, it provides a convenient interface to your recently and most frequently used commands.
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :init
    (smex-initialize)
    (setq smex-flex-matching nil)
    :bind (("M-x" . smex))
    )
#+END_SRC
** Ivy/Counsel/Swiper
[[https://github.com/abo-abo/swiper][Ivy]]  is a generic completion mechanism for Emacs. 
#+BEGIN_SRC emacs-lisp
(use-package ivy :ensure t
  :diminish (ivy-mode . "")
  :bind
  (:map ivy-mode-map
	("C-'" . ivy-avy)
	("C-x b" . ivy-switch-buffer)
	)
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; does not count candidates
  (setq ivy-count-format "")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
	;; allow input not in order
	'((t   . ivy--regex-ignore-order)))
  )

;; Counsel takes this further, providing versions of common Emacs commands that are customised to make the best use of ivy. 
(use-package counsel
  :ensure t
  :bind (
	 ("C-x C-f" . counsel-find-file)
	 ("C-h f" . counsel-describe-function)
	 ("C-h v" . counsel-describe-variable)
	 ("C-h b" . counsel-descbinds)
	 ("C-h l" . counsel-find-library)
	 ("M-y" . counsel-yank-pop)
	 )
  :config
  (setq counsel-find-file-at-point t)
  ;; * Generic ivy actions
  (ivy-set-actions
   t
   '(("i" (lambda (x) (with-ivy-window
		   (insert x))) "insert candidate")
     (" " (lambda (x) (ivy-resume)) "resume")
     ("?" (lambda (x)
	    (interactive)
	    (describe-keymap ivy-minibuffer-map)) "Describe keys")))

  ;; ** Find file actions
  (ivy-add-actions
   'counsel-find-file
   '(("a" (lambda (x)
	    (unless (memq major-mode '(mu4e-compose-mode message-mode))
	      (compose-mail)) 
	    (mml-attach-file x)) "Attach to email")
     ("c" (lambda (x) (kill-new (f-relative x))) "Copy relative path")
     ("4" (lambda (x) (find-file-other-window x)) "Open in new window")
     ("5" (lambda (x) (find-file-other-frame x)) "Open in new frame")
     ("C" (lambda (x) (kill-new x)) "Copy absolute path")
     ("d" (lambda (x) (dired x)) "Open in dired")
     ("D" (lambda (x) (delete-file x)) "Delete file")
     ("e" (lambda (x) (shell-command (format "open %s" x)))
      "Open in external program")
     ("f" (lambda (x)
	    "Open X in another frame."
	    (find-file-other-frame x))
      "Open in new frame")
     ("p" (lambda (path)
	    (with-ivy-window
	      (insert (f-relative path))))
      "Insert relative path")
     ("P" (lambda (path)
	    (with-ivy-window
	      (insert path)))
      "Insert absolute path")
     ("l" (lambda (path)
	    "Insert org-link with relative path"
	    (with-ivy-window
	      (insert (format "[[./%s]]" (f-relative path)))))
      "Insert org-link (rel. path)")
     ("L" (lambda (path)
	    "Insert org-link with absolute path"
	    (with-ivy-window
	      (insert (format "[[%s]]" path))))
      "Insert org-link (abs. path)")
     ("r" (lambda (path)
	    (rename-file path (read-string "New name: ")))
      "Rename")))
  )
;;Swiper is an alternative to isearch that uses ivy to show an overview of all matches.
(use-package swiper
  :ensure t
  :bind 
  ("C-s" . swiper) 
  )

(use-package imenu-anywhere
  :ensure t
  :bind
  ("C-c i" . ivy-imenu-anywhere)
  )
(use-package ace-link
  :ensure t
  :config 
  (ace-link-setup-default)
  (define-key org-mode-map (kbd "M-o") 'ace-link-org)
  )

(use-package flyspell-correct-ivy
  :ensure t
  :config
  (define-key flyspell-mode-map (kbd "C-c C-;") 'flyspell-correct-previous-word-generic)
  (add-hook 'flyspell-mode-hook 'flyspell-buffer )
  )

#+END_SRC

ivy functions 
#+BEGIN_SRC emacs-lisp
(defun ivy-insert-org-entity ()
  "Insert an org-entity using ivy."
  (interactive)
  (ivy-read "Entity: " (loop for element in (append org-entities org-entities-user)
			     when (not (stringp element))
			     collect
			     (cons 
			      (format "%10s | %s | %s | %s"
				      (car element) ;name
				      (nth 1 element) ; latex
				      (nth 3 element) ; html
				      (nth 6 element)) ;utf-8
			      element))
	    :require-match t
	    :action '(1
		      ("u" (lambda (element) (insert (nth 6 (cdr element)))) "utf-8")
		      ("o" (lambda (element) (insert "\\" (cadr element))) "org-entity")
		      ("l" (lambda (element) (insert (nth 1 (cdr element)))) "latex")
		      ("h" (lambda (element) (insert (nth 3 (cdr element)))) "html"))))

(defun ivy-org-jump-to-heading-in-files (files &optional fontify)
  "Jump to org heading in FILES.
Optional FONTIFY colors the headlines. It might slow things down
a lot with large numbers of org-files or long org-files. This
function does not open the files."
  (let ((headlines '())) 
    (loop for file in files do
	  (with-temp-buffer 
	    (insert-file-contents file)
	    (when fontify
	      (org-mode)
	      (font-lock-fontify-buffer))
	    (goto-char (point-min))
	    (while (re-search-forward org-heading-regexp nil t)
	      (cl-pushnew (list
			   (format "%-80s (%s)"
				   (match-string 0)
				   (file-name-nondirectory file))
			   :file file
			   :position (match-beginning 0))
			  headlines))))
    (ivy-read "Headline: "
	      (reverse headlines)
	      :action (lambda (candidate)
			(org-mark-ring-push)
			(find-file (plist-get (cdr candidate) :file))
			(goto-char (plist-get (cdr candidate) :position))
			(outline-show-entry)))))


(defun ivy-org-jump-to-heading-in-directory (&optional recursive)
  "Jump to heading in an org file in the current directory.
Use a prefix arg to make it RECURSIVE.
Use a double prefix to make it recursive and fontified."
  (interactive "P")
  (let ((fontify nil))
    (when (equal recursive '(16))
      (setq fontify t))
    (ivy-org-jump-to-heading-in-files
     (f-entries "."
		(lambda (f)
		  (and 
		   (f-ext? f "org")
		   (not (s-contains? "#" f))))
		recursive)
     fontify)))
#+END_SRC

** Ido 

#+BEGIN_SRC emacs-lisp
  (use-package ido
    :ensure t 
    :config
    (ido-mode t)
    (setq ido-enable-flex-matching t)
    (add-to-list 'ido-ignore-buffers "*Messages*")
    (use-package flx-ido
      :ensure t 
      :config 
      (flx-ido-mode t)
      (setq ido-use-faces nil)
      )
    )
#+END_SRC

** Auto-complete
[[https://github.com/auto-complete/auto-complete][Auto-Complete]] is an intelligent auto-completion extension for Emacs.
It extends the standard Emacs completion interface and provides an environment that allows users to concentrate more on their own work.
#+BEGIN_SRC emacs-lisp
  ;; (use-package auto-complete
  ;;   :ensure t
  ;;   :init
  ;;   (ac-config-default)
  ;;   (global-auto-complete-mode t)
  ;;   )
#+END_SRC
** Yasnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an abbreviation and automatically expand it into function templates.
#+BEGIN_SRC emacs-lisp

(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :init
  (yas-global-mode 1)
  (use-package yasnippet-snippets
    :ensure t
    )
  )
#+END_SRC

** Company
[[http://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for "complete anything".
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (add-hook 'after-init-hook 'global-company-mode)
  (add-hook 'prog-mode-hook 'company-mode))
(use-package company-quickhelp
  :ensure t
  :config
  (company-quickhelp-mode 1)
  )


#+END_SRC
** Winner mode 
[[https://www.emacswiki.org/emacs/WinnerMode][winner-mode]] lets you use C-c <left> and C-c <right> to switch between window configurations. This is handy when something has popped up a buffer
that you want to look at briefly before returning to whatever you were working on. When you're done, press C-c <left>.
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure t
    :config 
    (winner-mode))
#+END_SRC

** Undo Tree 
People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.
This lets you use C-x u (undo-tree-visualize) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :bind
  ("M-z" . undo-tree-redo)
  ("C-M-z" . undo-tree-visualize)
  :config
  (global-undo-tree-mode 1 )
  (setq undo-tree-visualizer-diff t)
  (setq undo-tree-auto-save-history t)
  (setq undo-tree-history-directory-alist `(("" . ,(concat user-emacs-directory "undo-tree/"))))
	)
#+END_SRC
** Expand region
[[https://github.com/magnars/expand-region.el][Expand region]] increases the selected region by semantic units. Just keep pressing the key until it selects what you want.
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :defer t
  :bind ("M-w" . er/expand-region)
  ("C-<next>" . er/contract-region)
  )
#+END_SRC
** Multi shell
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :ensure t
  :config
  (setq multi-term-program "/bin/zsh")
  (add-hook 'term-mode-hook
	    (lambda () (setq scroll-margin '0)
	      (hidden-mode-line-mode)))
  :bind (("M-]" . multi-term-next)
	 ("M-[" . multi-term-prev)
	 ("C-c s" . multi-term))
  )
#+END_SRC
** Flycheck

[[http://www.flycheck.org/en/latest/][flycheck]] Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode t)
    )
#+END_SRC
** Read aloud

[[https://github.com/gromnitsky/read-aloud.el][read aloud]] is a simple TTS engine
#+BEGIN_SRC emacs-lisp
  (use-package read-aloud
    :ensure t
    )

#+END_SRC
** Agressive intentation

[[https://github.com/Malabarba/aggressive-indent-mode][aggresive intentation]] is enough to keep your code nicely aligned when all you do is type.
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :config
  (global-aggressive-indent-mode 1)
  (add-to-list 'aggressive-indent-excluded-modes 'python-mode 'assembler-mode)
  )
#+END_SRC
** Elfeed

Elfeed is a RSS ,Atom reader for emacs
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t
    :config
    (defun bjm/elfeed-save-db-and-bury ()
      "Wrapper to save the elfeed db to disk before burying buffer"
      (interactive)
      (elfeed-db-save)
      (quit-window))
    (defun bjm/elfeed-load-db-and-open ()
      "Wrapper to load the elfeed db from disk before opening"
      (interactive)
      (elfeed-db-load)
      (elfeed)
      (elfeed-search-update--force))
    :bind (:map elfeed-search-mode-map
                ("q" . bjm/elfeed-save-db-and-bury)
                ))
  (use-package elfeed-goodies
    :ensure t
    :config
    (elfeed-goodies/setup)
    )

(use-package elfeed-org
  :ensure t
  :config
  (elfeed-org)
  (setq rmh-elfeed-org-files (list "~/Dropbox/OrgFiles/Emacs/elfeed.org")))
#+END_SRC
** Multiple Cursor 
[[https://github.com/gabesoft/evil-mc][Multiple Cursor]] We can do some serious stuffs with this
#+BEGIN_SRC emacs-lisp
  (use-package evil-mc
    :ensure t
    :init
    (global-evil-mc-mode 1)
    )

#+END_SRC
** Which key
[[https://github.com/justbur/emacs-which-key][which-key]] is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup. 

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :defer 10
    :diminish which-key-mode
    :config
    (which-key-mode)
    )
#+END_SRC
** pdf tools
PDF Files inside emacs 
#+BEGIN_SRC emacs-lisp
    (use-package pdf-tools
      :ensure t
      :config
      (pdf-tools-install)
      (bind-keys :map pdf-view-mode-map
                 ("\\" . hydra-pdftools/body))
  (defhydra hydra-pdftools (:color blue :hint nil)
        "
                                                                          ╭───────────┐
           Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
       ╭──────────────────────────────────────────────────────────────────┴───────────╯
          ^^^_g_^^^       _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search      [_u_] revert buffer
          ^^^^↑^^^^       ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline     [_i_] info
          ^^^_p_^^^       ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link        [_d_] midgnight mode
          ^^^^↑^^^^       ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link [_D_] print mode
     _h_ ← _e_/_t_ → _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
          ^^^^↓^^^^       ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
          ^^^_n_^^^       ^ ^  _r_eset slice box
          ^^^^↓^^^^
          ^^^_G_^^^
       --------------------------------------------------------------------------------
            "
        ("\\" hydra-master/body "back")
        ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ("y"  pdf-view-kill-ring-save)
        ("+" pdf-view-enlarge :color red)
        ("-" pdf-view-shrink :color red)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("n" pdf-view-next-page-command :color red)
        ("p" pdf-view-previous-page-command :color red)
        ("d" pdf-view-midnight-minor-mode)
        ("D" pdf-view-printer-minor-mode)
        ("b" pdf-view-set-slice-from-bounding-box)
        ("r" pdf-view-reset-slice)
        ("g" pdf-view-first-page)
        ("G" pdf-view-last-page)
        ("e" pdf-view-goto-page)
        ("t" pdf-view-goto-label)
        ("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red))

      )
#+end_src
** Image+
#+BEGIN_SRC emacs-lisp
  (use-package image+ 
    :ensure t
    :config
    (imagex-auto-adjust-mode 1)
  (bind-keys :map image-mode-map
	     ("\\"   . my/hydra-image/body))
    )

#+END_SRC
** grep/ag
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t
    :config
    (eval-after-load 'grep
      '(define-key grep-mode-map
         (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

    (eval-after-load 'wgrep
      '(define-key grep-mode-map
         (kbd "C-c C-c") 'wgrep-finish-edit)
      )
    )
  (use-package ag
    :ensure t
    :config
    (use-package wgrep-ag
      :ensure t)
    )
#+END_SRC
** DumpJump
Dump Jump to defenition package . It uses ag to find the defention .
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :bind (("M-g o" . dumb-jump-go-other-window)
           ("M-g j" . dumb-jump-go)
           ("M-g i" . dumb-jump-go-prompt)
           ("M-g x" . dumb-jump-go-prefer-external)
           ("M-g z" . dumb-jump-go-prefer-external-other-window))
    :config (setq dumb-jump-selector 'ivy) 
    )


#+END_SRC

** Boxquote
[[https://github.com/davep/boxquote.el][boxquote.el]] provides a set of functions for using a text quoting style that partially boxes in the left hand side of an area of text,
such a marking style might be used to show externally included text or example code.
#+BEGIN_SRC emacs-lisp
  (use-package boxquote
    :ensure t
    :defer t
    :config
    (setq-default  boxquote-bottom-corner "╰"      ; U+2570
                   boxquote-side          "│ "     ; U+2572 + space
                   boxquote-top-and-tail  "────"   ; U+2500 (×4)
                   boxquote-top-corner    "╭")     ; U+256F
    (when (package-installed-p 'hydra)
      (eval-and-compile
        (defhydra hydra-boxquote (:color blue :hint nil)
          "
                                                                      ╭──────────┐
    Text           External           Apropos         Do              │ Boxquote │
  ╭───────────────────────────────────────────────────────────────────┴──────────╯
    [_r_] region        [_f_] file      [_K_] describe-key        [_t_] title
    [_p_] paragraph     [_b_] buffer    [_F_] describe-function   [_u_] unbox
    [_a_] buffer        [_s_] shell     [_V_] describe-variable   [_w_] fill-paragraph
    [_e_] text           ^ ^            [_W_] where-is            [_n_] narrow
    [_d_] defun         [_y_] yank       ^ ^                      [_c_] narrow to content
    [_q_] boxquote      [_Y_] yanked     ^ ^                      [_x_] kill
  --------------------------------------------------------------------------------
         "
          ("<esc>" nil "quit")
          ("x" boxquote-kill)
          ("Y" boxquote-yank)
          ("e" boxquote-text)
          ("u" boxquote-unbox)
          ("d" boxquote-defun)
          ("t" boxquote-title)
          ("r" boxquote-region)
          ("a" boxquote-buffer)
          ("q" boxquote-boxquote)
          ("W" boxquote-where-is)
          ("p" boxquote-paragraph)
          ("f" boxquote-insert-file)
          ("K" boxquote-describe-key)
          ("s" boxquote-shell-command)
          ("b" boxquote-insert-buffer)
          ("y" boxquote-kill-ring-save)
          ("w" boxquote-fill-paragraph)
          ("F" boxquote-describe-function)
          ("V" boxquote-describe-variable)
          ("n" boxquote-narrow-to-boxquote)
          ("c" boxquote-narrow-to-boxquote-content)))))

#+END_SRC
** Git
*** Magit
[[https://magit.vc/][Magit]] is an interface to the version control system Git, implemented as an Emacs package. 
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    ("C-x g" . magit-status)
    :config

    ;; full screen magit-status
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen))
    (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
    )
#+END_SRC
** Pandoc
#+BEGIN_SRC emacs-lisp
  ;; (use-package ox-pandoc
  ;;   :ensure t
  ;;   )
  ;; (use-package pandoc-mode
  ;;   :ensure t
  ;;   )
#+END_SRC
** Markdown Mode
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC
** Shell Switcher
Multiple Eshell 
#+BEGIN_SRC emacs-lisp
  (use-package shell-switcher
    :ensure t
    :config
    (setq shell-switcher-mode t)
    :bind (("C-;" . shell-switcher-switch-buffer)
           ("C-x 4 '" . shell-switcher-switch-buffer-other-window)
           ("C-M-;" . shell-switcher-new-shell)))
#+END_SRC
** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker
  :ensure t
  )
#+END_SRC
** Prodigy
Manage external services from within Emacs 
#+BEGIN_SRC emacs-lisp
(use-package prodigy
  :ensure t
:config
(prodigy-define-service
  :name "Jekyll"
  :command "docker"
  :args '("run" "--rm" "--volume=/home/nemesis/Git/GitHub/vishnudevtj.github.io:/srv/jekyll" "-p" "4000:4000" "-it" "jekyll/jekyll" "jekyll" "serve" "--watch")
  :cwd "/home/nemesis/Git/GitHub/vishnudevtj.github.io"
  :tags '(blog jekyll)
  :stop-signal 'sigint
  :kill-process-buffer-on-stop t
            )
(prodigy-define-service
  :name "Jekyll"
  :command "docker"
  :args '("run" "--rm" "--volume=/home/nemesis/Git/GitLabs/inctf:/srv/jekyll" "-p" "4000:4000" "-it" "jekyll/jekyll" "jekyll" "serve" "--watch")
  :cwd "/home/nemesis/Git/GitLabs/inctf"
  :tags '(blog jekyll)
  :stop-signal 'sigint
  :kill-process-buffer-on-stop t
            )

  )
#+END_SRC

** Golden-Ratio
[[https://github.com/roman/golden-ratio.el][golden ratio]]
When working with many windows at the same time, each window has a size that is not convenient for editing.
golden-ratio helps on this issue by resizing automatically the windows you are working on to the size specified in the "Golden Ratio".
The window that has the main focus will have the perfect size for editing, while the ones that are not being actively edited
will be re-sized to a smaller size that doesn't get in the way, but at the same time will be readable enough to know it's content.
#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :config
  (golden-ratio-mode 1)
  (setq golden-ratio-adjust-factor .8
	golden-ratio-wide-adjust-factor .8)
  )
#+END_SRC
** Mingus
#+BEGIN_SRC emacs-lisp
(use-package mingus
  :ensure t
:config
(setenv "MPD_HOST" "127.0.0.1")
(setenv "MPD_PORT" "6601")
(global-set-key (kbd "C-c m") 'mingus)
)
#+END_SRC
** Persistant scratch
[[https://github.com/Fanael/persistent-scratch][persistent-scratch]] is an Emacs package that preserves the state of scratch buffers accross Emacs sessions by saving the state to and 
restoring it from a file.
#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :ensure t
  :config
  (persistent-scratch-setup-default)
  )
#+END_SRC
** fzf
fzf is a general-purpose command-line fuzzy finder.
#+BEGIN_SRC emacs-lisp
(use-package fzf
  :ensure t
  :config
  (setq fzf/executable "/opt/fzf/bin/fzf" )
  (global-set-key (kbd "C-p") 'fzf))
#+END_SRC

** Org Present 
#+BEGIN_SRC emacs-lisp

(use-package org-present
  :ensure t
  :init
  (autoload 'org-present "org-present" nil t)
  :config
  (bind-key "C-c M-p" 'org-present org-mode-map)
  (progn
    (add-hook 'org-present-mode-hook
	      (lambda ()
		(local-set-key (kbd "C-x p") #'org-present-prev)
		(local-set-key (kbd "C-x n") #'org-present-next)
		(org-present-small)
		(org-display-inline-images)
		(org-present-hide-cursor)
		(org-present-read-only)))
    (add-hook 'org-present-mode-quit-hook
	      (lambda ()
		;; (org-present-small)
		(org-remove-inline-images)
		(org-present-show-cursor)
		(org-present-read-write)))))
#+END_SRC

** Org reveal
#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :ensure t
  :config
  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.6.0/")
  )
#+END_SRC
* Evil Mode
Evil is an extensible vi layer for Emacs. It emulates the main features of Vim, and provides facilities for writing custom extensions.
Also see our page on EmacsWiki.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :config
  (evil-mode 1)
  (add-to-list 'evil-emacs-state-modes 'mingus-playlist-mode)
  (add-to-list 'evil-emacs-state-modes 'mingus-browse-mode)
  (add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)
  (add-to-list 'evil-emacs-state-modes 'mingus-browse-mode)
  (add-to-list 'evil-emacs-state-modes 'elfeed-show-mode)
  (add-to-list 'evil-emacs-state-modes 'special-mode)
  (add-to-list 'evil-emacs-state-modes 'eww-mode)
  (add-to-list 'evil-emacs-state-modes 'notmuch-tree-mode)
  (setq evil-insert-state-cursor  'box)
  

)

#+END_SRC

** Evil Packages
#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :ensure t 
  :config (global-evil-matchit-mode 1)
  )
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1)
  )
(use-package evil-nerd-commenter
  :ensure t
  :bind (("M-;" . evilnc-comment-or-uncomment-lines))
  )
;; evil Python 

(evil-define-key 'visual python-mode-map 
  (kbd "RET") 'python-shell-send-region)
(evil-define-key 'normal python-mode-map
  "gs" 'python-shell-switch-to-shell)
(use-package evil-goggles
  :ensure t
  :config
  (evil-goggles-mode))

;; (use-package evil-collection
;;   :ensure t
;;   :custom
;;   (evil-collection-setup-minibuffer t)
;;   :init
;;   (evil-collection-init))

#+END_SRC
* Tweak
** Dired
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lh --group-directories-first -t ") ;; make value human readable
(setq wdired-allow-to-change-permissions t)
(add-hook 'dired-mode-hook 'auto-revert-mode)
(setq dired-recursive-copies (quote always)) ; “always” means no asking
(setq dired-recursive-deletes (quote top)) ; “top” means ask once
(setq  diredp-dwim-any-frame-flag t
       diredp-hide-details-initially-flag nil
       )
(setq dired-dwim-target t) ;;If Split Window Copy path is other windows
(setq find-ls-option (quote ("-print0 | xargs -0 ls -la" . "-dilsb"))) ;making wdired work with find-dired 
;; (use-package  dired+
;;   :ensure t
;;   :config
;;   (custom-set-faces
;;    '(diredp-compressed-file-name ((t nil)))
;;    '(diredp-compressed-file-suffix ((t (:foreground "#7474FFFF7474"))))
;;    '(diredp-date-time ((t nil)))
;;    '(diredp-deletion ((t (:foreground "red"))))
;;    '(diredp-di-heading ((t nil)))
;;    '(diredp-dir-name ((t (:foreground "DodgerBlue1"))))
;;    '(diredp-dir-priv ((t nil)))
;;    '(diredp-exec-priv ((t nil)))
;;    '(diredp-file-name ((t nil)))
;;    '(diredp-file-suffix ((t (:foreground "#7474FFFF7474"))))
;;    '(diredp-flag-mark ((t (:foreground "Blue"))))
;;    '(diredp-flag-mark-line ((t nil)))
;;    '(diredp-no-priv ((t nil)))
;;    '(diredp-number ((t (:foreground "white"))))
;;    '(diredp-rare-priv ((t (:foreground "Green"))))
;;    '(diredp-read-priv ((t nil)))
;;    '(diredp-write-priv ((t nil)))
;;    )
;;   )

;; Hitting S Brings up Dired sort menu
(use-package dired-quick-sort
  :ensure t
  :config
  (dired-quick-sort-setup))

(use-package dired-subtree
  :ensure t
  :config
  (define-key dired-mode-map ">" 'dired-subtree-insert)
  (define-key dired-mode-map "<" 'dired-subtree-remove)
  )

(define-key dired-mode-map "e"
  ;; Force the creation of a new Eshell instance at this path.
  (lambda ()
    (interactive)
    (eshell t)))
#+END_SRC
** Eshell
Most of the code copied from [[http://fasciism.com/][fasciism]] 
#+BEGIN_SRC emacs-lisp
  (setq eshell-history-size 100000
        eshell-scroll-to-bottom-on-input t
        eshell-save-history-on-exit t
        eshell-hist-ignoredups t
        tramp-default-method "ssh"
        )

(add-hook 'eshell-mode-hook
   (lambda ()
     (add-to-list 'eshell-visual-commands "ssh")
     (add-to-list 'eshell-visual-commands "htop")
     (add-to-list 'eshell-visual-commands "ncmpcpp")
     (add-to-list 'eshell-visual-commands "tail")))

  (defun eshell/d ()
    "Open a dired instance of the current working directory."
    (dired "."))
  (defun eshell/q ()
    "Send the *eshell* buffer to the back of buffer list."
    (bury-buffer))
  (defun eshell/x ()
    (insert "exit")
    (eshell-send-input)
    (delete-window))


  (defun eshell/kill-previous-output (&optional nth)
    "Copies the output of the previous command to the kill ring.
  When nth is set, it will copy the nth previous command."
    (save-excursion
      ;; Move to the end of the eshell buffer.
      (goto-char (point-max))
      ;; Move to the start of the last prompt.
      (search-backward-regexp eshell-prompt-regexp nil nil nth)
      ;; Move to the start of the line, before the prompt.
      (beginning-of-line)
      ;; Remember this position as the end of the region.
      (let ((end (point)))
        ;; Move to the start of the last prompt.
        (search-backward-regexp eshell-prompt-regexp)
        ;; Move one line below the prompt, where the output begins.
        (next-line)
        ;; Find first line that's not blank.
        (while (looking-at "^[[:space:]]*$")
          (beginning-of-line)
          (next-line))
        ;; Copy region to kill ring.
        (copy-region-as-kill (point) end)
        ;; Output stats on what was copied as a sanity check.
        (format "Copied %s words to kill ring." (count-words-region (point) end)))))
  (defun mak::get-buffer-path (&optional name)
    "Finds the current path, including for Eshell buffers where it is the working directory."
    (interactive "b")
    (with-current-buffer name
      (if (eq major-mode 'eshell-mode)
          (substring-no-properties default-directory)
        (buffer-file-name))))

  (defun mak::get-buffer-tramp-context (&optional name)
    "Finds a buffer's Tramp context based on its file name."
    (interactive "b")
    (let ((path (mak::get-buffer-path name)))
      ;; Match single and chained contexts.
      (if (string-match "^\\(/\\(ssh\\|sudo\\):[^:|]+\\(|\\(ssh\\|sudo\\):[^:|]+\\)*:\\)" path)
          (match-string 1 path)
        (user-error "Failed to find Tramp context in path %s." path))))

  (defun mak::get-last-hop-from-tramp-context (ctx)
    "Finds the last host or user@host hop in a Tramp context."
    (if (string-match "[/:]\\(?:ssh\\|sudo\\):\\([^:]+\\):$" ctx)
        (match-string 1 ctx)
      (user-error "Failed to find last hop in context %s." ctx)))

  (defun mak::tramp-remote-find-file-with-sudo (file)
    "Attempts to open a file using Tramp and Sudo."
    ;; We need to currently be within a Tramp 'context'.
    (let* ((ctx (mak::get-buffer-tramp-context (current-buffer)))
           (hop (mak::get-last-hop-from-tramp-context ctx)))
      (find-file (format "%s|sudo:%s:%s"
                         (substring ctx 0 -1)
                         hop
                         file))))

  (defun eshell/f (file)
    "An alias for find-file."
    (find-file file))

  (defun eshell/f! (file)
    "An alias for find-file-with-sudo."
    (if (equal "/" (substring file 0 1))
        (find-file (concat "/sudo::" file))
      (mak::tramp-remote-find-file-with-sudo file)))

  (global-set-key (kbd "C-x s") 'my/eshell-fullscreen)
  (defun my/eshell-fullscreen ()
    "Bring up a full-screen eshell or restore previous config."
    (interactive)
    (if (string= "eshell-mode" major-mode)
        (jump-to-register :eshell-fullscreen)
      (progn
        (window-configuration-to-register :eshell-fullscreen)
        (eshell)
        (delete-other-windows))))

;; (epe-colorize-with-face "abc" 'font-lock-comment-face)
(defmacro epe-colorize-with-face (str face)
  `(propertize ,str 'face ,face))

(defface epe-venv-face
  '((t (:inherit font-lock-comment-face)))
  "Face of python virtual environment info in prompt."
  :group 'epe)

(defun eshell-here ()
  "Opens up a new shell in the directory associated with the
current buffer's file. The eshell is renamed to match that
directory to make multiple eshell windows easier."
  (interactive)
  (let* ((parent (if (buffer-file-name)
                     (file-name-directory (buffer-file-name))
                   default-directory))
         (height (/ (window-total-height) 3))
         (name   (car (last (split-string parent "/" t)))))
    (split-window-vertically (- height))
    (other-window 1)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))

    (insert (concat "ls"))
    (eshell-send-input)))

(global-set-key (kbd "C-!") 'eshell-here)

(add-hook 'eshell-mode-hook
	  (lambda () (setq scroll-margin '0)
	    (hidden-mode-line-mode)))

#+END_SRC
* Functions 
#+BEGIN_SRC emacs-lisp
  (defun switch-to-previous-buffer ()
    "Switch to previously open buffer.
  Repeated invocations toggle between the two most recently open buffers."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
  (global-set-key (kbd "C-c b") 'switch-to-previous-buffer)
  (defun my/j()
    (find-file "~/Dropbox/Files/j.gpg")
    )
#+END_SRC

This is a cool funtion from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Paranthesis]]  which narrows and if it is already narrowed it widens 

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
          Dwim means: region, org-src-block, org-subtree, or
          defun, whichever applies first. Narrowing to
          org-src-block actually calls `org-edit-src-code'.

          With prefix P, don't widen, just narrow even if buffer
          is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))
  (bind-key "C-c n" 'narrow-or-widen-dwim)
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defvar-local hidden-mode-line-mode nil)
  (defvar-local hide-mode-line nil)

  (define-minor-mode hidden-mode-line-mode
    "Minor mode to hide the mode-line in the current buffer."
    :init-value nil
    :global nil
    :variable hidden-mode-line-mode
    :group 'editing-basics
    (if hidden-mode-line-mode
        (setq hide-mode-line mode-line-format
              mode-line-format nil)
      (setq mode-line-format hide-mode-line
            hide-mode-line nil))
    (force-mode-line-update)
    ;; Apparently force-mode-line-update is not always enough to
    ;; redisplay the mode-line
    (redraw-display)
    (when (and (called-interactively-p 'interactive)
               hidden-mode-line-mode)
      (run-with-idle-timer
       0 nil 'message
       (concat "Hidden Mode Line Mode enabled.  "
               "Use M-x hidden-mode-line-mode to make the mode-line appear."))))
#+END_SRC
Link to [[man:man][man]]  page 
#+BEGIN_SRC emacs-lisp
;;Link to Man page
(defun org-man-store-link ()
  "Store a link to a man page."
  (when (memq major-mode '(Man-mode woman-mode))
    (let* ((page (save-excursion
		   (goto-char (point-min))
		   (re-search-forward " ")
		   (buffer-substring (point-min) (point))))
	   (link (concat "man:" page))
	   (description (format "Manpage for %s" page)))
      (org-store-link-props
       :type "man"
       :link link
       :description description))))

(if (fboundp 'org-link-set-parameters)
    (org-link-set-parameters
     "man"
     :follow (lambda (path)
	       (man path))
     :store 'org-man-store-link))


#+END_SRC

Sudo Editing
#+BEGIN_SRC emacs-lisp
(defadvice ido-find-file (after find-file-sudo activate)
  "Find file as root if necessary."
  (unless (and buffer-file-name
               (file-writable-p buffer-file-name))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
(defun sudo-edit (&optional arg)
  "Edit currently visited file as root.

With a prefix ARG prompt for a file to visit.
Will also prompt for a file to visit if current
buffer is not visiting a file."
  (interactive "P")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:"
                         (ido-read-file-name "Find file(as root): ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
(global-set-key (kbd "C-x C-r") 'sudo-edit)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun writing-mode ()
  (interactive)
  (face-remap-add-relative 'org-level-1 :foregound "#000000" )
  (face-remap-add-relative 'org-level-2 :foregound "#000000" :slant 'italic)
  (face-remap-add-relative 'org-level-3 :foregound "#000000")
  ;; (setq org-bullets-bullet-list '(" " " " " " " " " " " " " " " " " " " " " "))
  (org-mode)
  (hidden-mode-line-mode)
  (relative-line-numbers--off)
(load-theme-buffer-local 'github (current-buffer))
(setq org-hide-leading-stars t)
)

#+END_SRC

** Leet
#+BEGIN_SRC emacs-lisp
(defun leet (start end)
  "Convert the selected line to 1337"
  (interactive "r")
  (progn
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (while (search-forward "a" nil t)
	(replace-match "4" nil t))
      (goto-char (point-min))
      (while (search-forward "e" nil t)
	(replace-match "3" nil t))
      (goto-char (point-min))
      (while (search-forward "g" nil t)
	(replace-match "6" nil t))
      (goto-char (point-min))
      (while (search-forward "l" nil t)
	(replace-match "1" nil t))
      (goto-char (point-min))
      (while (search-forward "o" nil t)
	(replace-match "0" nil t))
      (goto-char (point-min))
      (while (search-forward "s" nil t)
	(replace-match "5" nil t))
      (goto-char (point-min))
      (while (search-forward "t" nil t)
	(replace-match "7" nil t))
      ))
  )
#+END_SRC
* Programming Language
** Python
*** Setting
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "ipython3"
      python-shell-interpreter-args " -i")

(setenv "PYTHONPATH" "/home/nemesis/bi0s/library/python")

#+END_SRC
When Using Ipython using arrow to get the previous history does not work
this can be solved by 
#+BEGIN_SRC emacs-lisp
(eval-after-load 'comint
  '(progn
     ;; originally on C-c M-r and C-c M-s
     (define-key comint-mode-map (kbd "M-p") #'comint-previous-matching-input-from-input)
     (define-key comint-mode-map (kbd "M-n") #'comint-next-matching-input-from-input)
     ;; originally on M-p and M-n
     (define-key comint-mode-map (kbd "C-c M-r") #'comint-previous-input)
     (define-key comint-mode-map (kbd "C-c M-s") #'comint-next-input)))

#+END_SRC

*** Jedi
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :ensure t
    :init
    (defun my/python-mode-hook ()
    (add-to-list 'company-backends 'company-jedi))
    (add-hook 'python-mode-hook 'my/python-mode-hook)
    )
#+END_SRC
- dependencies
    #+BEGIN_SRC sh
    sudo pip insyall jedi
    #+END_SRC
*** Elpy
#+BEGIN_SRC emacs-lisp
(use-package pyvenv
  :ensure t
  )
(use-package elpy
  :ensure t
  :init
  (elpy-enable)
  ;; (elpy-use-ipython)
  (setq elpy-rpc-python-command "/usr/bin/python3")
  (setq elpy-modules '(elpy-module-sane-defaults
		       elpy-module-company
		       elpy-module-eldoc
		       elpy-module-flymake
		       elpy-module-pyvenv
		       elpy-module-yasnippet))
;; use flycheck not flymake with elpy
(when (require 'flycheck nil t)
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode))
(setq elpy-rpc-backend "jedi")
  )
#+END_SRC
*** pep8
#+BEGIN_SRC emacs-lisp
;; (use-package py-autopep8
;;   :ensure t
;;   :config
;;  (add-hook 'python-mode-hook 'py-autopep8-enable-on-save)
;;  (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
;;   )
#+END_SRC
- dependencies
    #+BEGIN_SRC sh
    sudo pip insyall autopep8
    #+END_SRC
** HTML
*** Web Mode
[[http://web-mode.org/][web-mode]] is a major-mode for editing web pages
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-quoting t)
    )
#+END_SRC

*** Raindow Mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  )
#+END_SRC
** Assembly language
#+BEGIN_SRC emacs-lisp
(use-package x86-lookup
  :ensure t
  :config
  (setq  x86-lookup-pdf "~/Dropbox/Books/Hacking/64-iA32-Instruction-set-reference-vol2.pdf")
  )
(use-package nasm-mode
  :ensure t
  :config
  (add-hook 'asm-mode-hook 'nasm-mode)
  )
#+END_SRC
* Custom Faces
** Org
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(org-level-1 ((t (:inherit outline-1 :height 1.3))))
 '(org-level-2 ((t (:inherit outline-2 :height 1.1))))
 '(org-level-3 ((t (:inherit outline-3 :height 1.0)))))
#+END_SRC
** Banner 
#+BEGIN_SRC emacs-lisp

;; (defun insert-ascii-banner-centered (file)
;;   "Insert banner from FILE."
;;   (insert
;;    (with-temp-buffer
;;      (insert-file-contents file)
;;      (let ((banner-width 0))
;;        (while (not (eobp))
;;          (let ((line-length (- (line-end-position) (line-beginning-position))))
;;            (if (< banner-width line-length)
;;                (setq banner-width line-length)))
;;          (forward-line 1))
;;        (goto-char 0)
;;        (let ((margin (max 0 (floor (/ (- 150 banner-width) 2)))))
;;          (while (not (eobp))
;; 	   (insert (make-string margin ?\ ))
;;            (forward-line 1))))
;;      (buffer-string))))
;; (progn
;;   (switch-to-buffer-other-window "banner")
;;   (org-mode)
;;   (delete-other-windows)
;;   (erase-buffer)
;;   (insert-ascii-banner-centered  "~/.emacs.d/banner")
;;   (put-text-property (point-min) (point-max) 'font-lock-face '(:foreground "#51afef"))
;;   (read-only-mode)
;;   )

#+END_SRC
* CTF
#+BEGIN_SRC emacs-lisp
(setq ctf-base-directory "~/bi0s/ctf/")
(defun ctf-init (name)
"Initialize  files and folder for ctf "
(interactive"MEnter name : ")
(setq  name (replace-regexp-in-string " " "" (capitalize name )))
(if (file-exists-p (concat ctf-base-directory name)) (message "File Exist")
  (make-directory (concat ctf-base-directory name)))
(setq name (concat name "/" (format-time-string "%Y")))
(if (file-exists-p  (concat ctf-base-directory name)) (message "File Exist")
  (make-directory (concat ctf-base-directory name)))
(write-region "" "" (concat  ctf-base-directory name "/note.org"))
(write-region "" "" (concat  ctf-base-directory name "/writeup.org"))
(make-directory (concat  ctf-base-directory name "/files"))
(find-file (concat ctf-base-directory name "/note.org"))
(insert "ctf")
(yas-expand)
(insert (capitalize  name))
)

(defun list-org-file-link ( name )
  "returns the list of files link in a org "
  (with-temp-buffer
    (save-excursion
      (let  ((file-list nil))
	(insert-file-contents name)
	(goto-char (point-min))
	(while (re-search-forward "\\[\\[file:\\(.*?\\)\\]\\[?.*\\]?\\]" nil t)
	  (add-to-list 'file-list (match-string-no-properties 1 )))
	file-list
	))))
(defun copy-file-list(scr-list dest )
  "copy a list of files to destinatin directory"
  (while scr-list
    (copy-file  (car scr-list) dest t t t t)
    (setq scr-list (cdr scr-list))))


(defun org-copy-file (name destination)
  "copy all the file link in a org file to destination folder
and correct the links "
  (interactive "bBuffer: \nfDestination : \n")
  (copy-file-list (list-org-file-link name) destination)
  (goto-char (point-min))
  (while (re-search-forward "\\[\\[file:\\(.*?\\)\\]\\[?.*\\]?\\]" nil t)
    (replace-match
     (concat destination (file-name-nondirectory  (match-string-no-properties 1))) nil nil nil 1 ))
  )

#+END_SRC





Rop Gadget search 

#+BEGIN_SRC emacs-lisp

(defun counsel-rop (arg)
  "ROP gadget Search for a bianry"
  (interactive "fFile name : ")
  (progn
    (setq buffer-name (concat (file-name-base arg ) "_gadgets"))
    (if (get-buffer buffer-name) ()
      (progn
	(shell-command (concat "ROPgadget " " --binary " arg) buffer-name)
	(with-current-buffer buffer-name 
	  (bury-buffer))))
    (with-current-buffer buffer-name
      (setq cantidates (split-string (buffer-string) "\n" t))
      ))
  (ivy-read " Gadget : " cantidates
	    :re-builder #'ivy--regex-fuzzy
	    :action #'insert
	    :caller 'counsel-rop
	    ))

(ivy-set-actions
 'counsel-rop
 '(("a" (lambda (x) (insert (car (split-string x "\:")))) "Insert Address")
   ("r" (lambda (x) (insert (cdr (split-string x "\:")))) "Insert Gadget"))
 )
#+END_SRC

* EXWM
#+BEGIN_SRC emacs-lisp
;; (use-package exwm
;;   :ensure t
;;   :config
;;   (require 'exwm-randr)
;; (setq exwm-randr-workspace-output-plist '(1 "LVDS-1"))
;; (add-hook 'exwm-randr-screen-change-hook
;; 	  (lambda ()
;;             (start-process-shell-command
;;              "xrandr" nil "xrandr --output HDMI-1  --primary --above LVDS-1 --auto")))
;; (require 'exwm-config)
;; (require 'exwm-systemtray)
;; (exwm-systemtray-enable)
;; (exwm-randr-enable)
;; (exwm-config-default)
;; )
#+END_SRC

